<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Упражнение - вёрстка статьи</title>
</head>
<body>
<h2>Мотивация</h2>
<img 
src="./images/image1.jpg" 
alt="Картинка из статьи">
<img 
src="http://cdn-bucket.hb.bizmrg.com/purple-images/posts/ps-architecture-notation/image1.jpg" 
alt="Картинка из статьи">
<p>
Я, как технический директор, регулярно сталкиваюсь с необходимостью обсудить с <br />
командой архитектуру нового приложения или микросервиса. И в рамках таких <br />
обсуждений я понял, что не существует единого подхода, который позволил бы <br />
эффективно общаться команде, обсуждая архитектурные решения.
</p>
<p>
Понятно, что на словах это не объяснишь и приходится прибегать к дополнительным <br />
инструментам в виде доски и маркера или же при текущих реалиях - online доски типа <br />
<a href="https://miro.com" target="_blank">Miro</a>. Но даже в этом случае обсуждение сваливается в хаотично нарисованные <br />
квадратики, круги или прямоугольники с текстом, как-то соединённые стрелками. 
</p>
<p>
При этом от обсуждения к обсуждению одна и так же схема может быть нарисована 1000 <br />
разными способами. Кто-то в творческом порыве начинает рисовать иконки <br />
пользователей или серверов, а кто-то рисует поток из 10 стрелок, чтобы показать все <br />
возможные варианты взаимодействия. И это - не эффективная коммуникация, где одно и <br />
тоже можно понять по-разному при этом потратив какое-то время на пояснение чем <br />
шестиугольник отличается круга.
</p>

<h2>А что есть?</h2>
<p>Осознав проблемы я первым делом начал искать готовые варианты. Вот несколько из них: </p>
<ul>
    <li>
        Диаграмма классов - иногда бывает удобной для анализа уже существующего кода, <br />
        но не применима для изначального проектирования, где мы оперируем более <br />
        верхне уровневыми объектами. 
    </li>
    <li>
        c4model - уже ближе к теме и предлагает 4 уровня детализации схемы программного <br />
        обеспечения. Но часто из всех 4-х уровней подходит 3-й, когда мы планируем новый <br />
        сервис, а на 3-м уровне стандартов описания немного. Отлично подходит для <br />
        верхнего уровня описания системы, но при детализации на компоненты не имеет <br />
        детальных стандартов. 
    </li>
</ul>


<p>
    Потому после нескольких экспериментов, я решил подготовить простую нотацию, которая <br />
    позволит описать архитектуру приложений на том уровне, чтобы мы могли:
</p>
<ul>
    <li>Разбить создание его на задачи.</li>
    <li>Проверить корректность деления на модули, чтобы сократить их связанность.</li>
    <li>
        Упростить коммуникацию в команде при обсуждении деталей проектирования <br />
        приложения.
    </li>
    <li>
        Использовать её для документирования архитектуры как монолита, так и <br />
        микросервисов.
    </li>
</ul>
<h3>Требования к нотации</h3>

<p>
    Перед тем, как переходить к описанию предлагаемой нотации следует сформулировать <br />
    требования, которым она должна удовловетворять:
</p>
<ul>
    <li>
        Она должна на верхнем уровне описывать отделимые части системы, которые далее я <br />
        буду назвать «компоненты».
    </li>
    <li>
        Связи между ними должны описать зависимости и поток вызовов, но не быть слишком <br />
        усложнены. По связям должно быть сразу понятно наличии архитектурных ошибок.
    </li>
    <li>
        Схема должна подходить как для описания монолитного приложения, так и <br />
        микросервисной архитектору.
    </li>
    <li>
        Фокус должен быть на описании нашей архитектуры, максимально абстрагировавшись от <br />
        внешних систем.
    </li>
</ul>
<p>
    Ниже будет написано мое видение такой нотации с учётом опыта тестирования её вместе с <br />
    командой. На практике она позволила в кратчайшие сроки обсуждать изменения в <br />
    архитектуре или планировать полноценные новые сервисы или приложения.
</p>
</body>
</html>